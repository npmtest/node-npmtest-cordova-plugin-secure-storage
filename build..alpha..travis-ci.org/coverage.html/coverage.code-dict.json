{"/home/travis/build/npmtest/node-npmtest-cordova-plugin-secure-storage/test.js":"/* istanbul instrument in package npmtest_cordova_plugin_secure_storage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-secure-storage/lib.npmtest_cordova_plugin_secure_storage.js":"/* istanbul instrument in package npmtest_cordova_plugin_secure_storage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cordova_plugin_secure_storage = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cordova_plugin_secure_storage = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-secure-storage/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cordova-plugin-secure-storage && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cordova_plugin_secure_storage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cordova_plugin_secure_storage\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cordova_plugin_secure_storage.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_cordova_plugin_secure_storage.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cordova_plugin_secure_storage.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_cordova_plugin_secure_storage.__dirname +\n                    '/lib.npmtest_cordova_plugin_secure_storage.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-secure-storage/node_modules/cordova-plugin-secure-storage/www/securestorage.js":"var SecureStorage, SecureStorageiOS, SecureStorageAndroid, SecureStorageWindows, SecureStorageBrowser;\nvar sjcl_ss = cordova.require('cordova-plugin-secure-storage.sjcl_ss');\nvar _AES_PARAM = {\n    ks: 256,\n    ts: 128,\n    mode: 'ccm',\n    cipher: 'aes'\n};\n\nvar _checkCallbacks = function (success, error) {\n    if (typeof success != 'function') {\n        throw new Error('SecureStorage failure: success callback parameter must be a function');\n    }\n    if (typeof error != 'function') {\n        throw new Error('SecureStorage failure: error callback parameter must be a function');\n    }\n};\n\n//Taken from undescore.js\nvar _isString = function isString(x) {\n    return Object.prototype.toString.call(x) === '[object String]';\n};\n\nvar _checkIsString = function(value){\n    if (!_isString(value)) {\n        throw new Error('Value is not a String');\n    }\n};\n\nvar _merge_options = function (defaults, options){\n    var res = {};\n    var attrname;\n\n    for (attrname in defaults) {\n        res[attrname] = defaults[attrname];\n    }\n    for (attrname in options) {\n        if (res.hasOwnProperty(attrname)) {\n            res[attrname] = options[attrname];\n        } else {\n            throw new Error('SecureStorage failure: invalid option ' + attrname);\n        }\n    }\n\n    return res;\n};\n\n/**\n * Helper method to execute Cordova native method\n *\n * @param   {String}    nativeMethodName Method to execute.\n * @param   {Array}     args             Execution arguments.\n * @param   {Function}  success          Called when returning successful result from an action.\n * @param   {Function}  error            Called when returning error result from an action.\n *\n */\nvar _executeNativeMethod = function (success, error, nativeMethodName, args) {\n    var fail;\n    // args checking\n    _checkCallbacks(success, error);\n\n    // By convention a failure callback should always receive an instance\n    // of a JavaScript Error object.\n    fail = function(err) {\n        // provide default message if no details passed to callback\n        if (typeof err === 'undefined') {\n            error(new Error('Error occured while executing native method.'));\n        } else {\n            // wrap string to Error instance if necessary\n            error(_isString(err) ? new Error(err) : err);\n        }\n    };\n\n    cordova.exec(success, fail, 'SecureStorage', nativeMethodName, args);\n};\n\nSecureStorageiOS = function (success, error, service) {\n    this.service = service;\n    setTimeout(success, 0);\n    return this;\n};\n\nSecureStorageiOS.prototype = {\n    get: function (success, error, key) {\n        try {\n            _executeNativeMethod(success, error, 'get', [this.service, key]);\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    set: function (success, error, key, value) {\n        try {\n            _checkIsString(value);\n            _executeNativeMethod(success, error, 'set', [this.service, key, value]);\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    remove: function (success, error, key) {\n        try {\n            _executeNativeMethod(success, error, 'remove', [this.service, key]);\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    keys: function (success, error) {\n        try {\n            _executeNativeMethod(success, error, 'keys', [this.service]);\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    clear: function (success, error) {\n        try {\n            _executeNativeMethod(success, error, 'clear', [this.service]);\n        } catch (e) {\n            error(e);\n        }\n    }\n};\n\n// SecureStorage for Windows web interface and proxy parameters are the same as on iOS\n// so we don't create own definition for Windows and simply re-use iOS\nSecureStorageWindows = SecureStorageiOS;\n\nSecureStorageAndroid = function (success, error, service, options) {\n    var self = this;\n    if (options) {\n        this.options = _merge_options(this.options, options);\n    }\n\n    this.service = service;\n    try {\n        _executeNativeMethod(\n            function (native_aes_supported) {\n                var checkMigrateToNativeAES;\n\n                checkMigrateToNativeAES = function () {\n                    self.options.native = native_aes_supported && self.options.native;\n                    if (!self.options.native){\n                        success();\n                    } else {\n                        _executeNativeMethod(\n                            function () {\n                                success();\n                            },\n                            function() {\n                                self._migrate_to_native_aes(success);\n                            },\n                            'fetch',\n                            ['_SS_MIGRATED_TO_NATIVE']\n                        );\n                    }\n                };\n\n                if (self.options.migrateLocalStorage){\n                    self._migrate_to_native_storage(checkMigrateToNativeAES);\n                } else {\n                    _executeNativeMethod(\n                        function () {\n                            checkMigrateToNativeAES();\n                        },\n                        function() {\n                            self._migrate_to_native_storage(checkMigrateToNativeAES);\n                        },\n                        'fetch',\n                        ['_SS_MIGRATED_TO_NATIVE_STORAGE']\n                    );\n                }\n            },\n            error,\n            'init',\n            [this.service]\n        );\n    } catch (e) {\n        error(e);\n    }\n    return this;\n};\n\nSecureStorageAndroid.prototype = {\n    options: {\n        native: true,\n        migrateLocalStorage: false\n    },\n\n    get: function (success, error, key) {\n        try {\n            if (this.options.native) {\n                this._native_get(success, error, key);\n            } else {\n                this._sjcl_get(success, error, key);\n            }\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    set: function (success, error, key, value) {\n        try {\n            _checkIsString(value);\n            if (this.options.native) {\n                this._native_set(success, error, key, value);\n            } else {\n                this._sjcl_set(success, error, key, value);\n            }\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    keys: function (success, error) {\n        try {\n            _executeNativeMethod(\n                function (ret) {\n                    var i, len = ret.length, keys = [];\n                    for (i = 0; i < len; ++i) {\n                        if (ret[i] && ret[i].slice(0, 4) === '_SS_') {\n                            keys.push(ret[i].slice(4));\n                        }\n                    }\n                    success(keys);\n                },\n                error,\n                'keys',\n                []\n            );\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    remove: function (success, error, key) {\n        try {\n            _executeNativeMethod(\n                function () {\n                    success(key);\n                },\n                error,\n                'remove',\n                ['_SS_' + key]\n            );\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    secureDevice: function (success, error) {\n        try {\n            _executeNativeMethod(\n                success,\n                error,\n                'secureDevice',\n                []\n            );\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    clear: function (success, error) {\n        try {\n            _executeNativeMethod(\n                success,\n                error,\n                'clear',\n                []\n            );\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    _fetch: function (success, error, key) {\n        _executeNativeMethod(\n            function (value) {\n                success(value);\n            },\n            error,\n            'fetch',\n            ['_SS_' + key]\n        );\n    },\n\n    _sjcl_get: function (success, error, key) {\n        var payload;\n        _executeNativeMethod(\n            function (value) {\n                payload = JSON.parse(value);\n                _executeNativeMethod(\n                    function (AESKey) {\n                        var value, AESKeyBits;\n                        try {\n                            AESKeyBits = sjcl_ss.codec.base64.toBits(AESKey);\n                            value = sjcl_ss.decrypt(AESKeyBits, payload.value);\n                            success(value);\n                        } catch (e) {\n                            error(e);\n                        }\n                    },\n                    error,\n                    'decrypt_rsa',\n                    [payload.key]\n                );\n            },\n            error,\n            'fetch',\n            ['_SS_' + key]\n        );\n    },\n\n    _sjcl_set: function (success, error, key, value) {\n        var AESKey, encValue;\n\n        AESKey = sjcl_ss.random.randomWords(8);\n        _AES_PARAM.adata = this.service;\n        encValue = sjcl_ss.encrypt(AESKey, value, _AES_PARAM);\n        // Encrypt the AES key\n        _executeNativeMethod(\n            function (encKey) {\n                _executeNativeMethod(\n                    function () {\n                        success(key);\n                    },\n                    error,\n                    'store',\n                    ['_SS_' + key, JSON.stringify({key: encKey, value: encValue})]\n                );\n            },\n            error,\n            'encrypt_rsa',\n            [sjcl_ss.codec.base64.fromBits(AESKey)]\n        );\n    },\n\n    _native_get: function (success, error, key) {\n        _executeNativeMethod(\n            success,\n            error,\n            'get',\n            ['_SS_' + key]\n        );\n    },\n\n    _native_set: function (success, error, key, value) {\n        _executeNativeMethod(\n            function () {\n                success(key);\n            },\n            error,\n            'set',\n            ['_SS_' + key, value, this.service]\n        );\n    },\n\n    _migrate_to_native_storage: function (success) {\n        var key;\n        var secureStorageData = [];\n        var entriesCnt = 0;\n        var entriesProcessed = 0;\n        var entryMigrated;\n        var migrated;\n        var migrateEntry;\n\n        migrated = function () {\n            _executeNativeMethod(\n                function () {\n                    success();\n                },\n                function () {\n                },\n                'store',\n                ['_SS_MIGRATED_TO_NATIVE_STORAGE', '1']\n            );\n        };\n\n        entryMigrated = function () {\n            entriesProcessed++;\n            if (entriesProcessed === entriesCnt) {\n                migrated();\n            }\n        };\n\n        migrateEntry = function (key, value) {\n            _executeNativeMethod(\n                function () {\n                    localStorage.removeItem(key);\n                    entryMigrated();\n                },\n                function () {\n                },\n                'store',\n                [key, value]\n            );\n        };\n\n        for (key in localStorage) {\n            if (localStorage.hasOwnProperty(key) && key.indexOf('_SS_') === 0) {\n                entriesCnt++;\n                secureStorageData[key] = localStorage.getItem(key);\n            }\n        }\n        if (entriesCnt === 0) {\n            migrated();\n        } else {\n            for (key in secureStorageData) {\n                if (secureStorageData.hasOwnProperty(key)) {\n                    migrateEntry(key, secureStorageData[key]);\n                }\n            }\n        }\n    },\n\n    _migrate_to_native_aes: function (success) {\n        var self = this;\n        var keysCnt, keysProcessed;\n        var keyProcessed;\n        var migrated;\n        var migrateKey;\n        var i;\n\n        migrated = function () {\n            _executeNativeMethod(\n                function () {\n                    success();\n                },\n                function () {\n                },\n                'store',\n                ['_SS_MIGRATED_TO_NATIVE', '1']\n            );\n        };\n\n        keyProcessed = function () {\n            keysProcessed++;\n            if (keysProcessed === keysCnt) {\n                migrated();\n            }\n        };\n\n        migrateKey = function (key) {\n            var payload;\n            _executeNativeMethod(\n                function (value) {\n                    payload = JSON.parse(value);\n                    if (!payload.native) {\n                        self._sjcl_get(\n                            function (value) {\n                                self._native_set(\n                                    function () {\n                                        keyProcessed();\n                                    },\n                                    function () {},\n                                    key.replace('_SS_', ''),\n                                    value\n                                );\n                            },\n                            function () {},\n                            key.replace('_SS_', '')\n                        );\n                    } else {\n                        keyProcessed();\n                    }\n                },\n                function () {\n                },\n                'fetch',\n                [key]\n            );\n        };\n\n        _executeNativeMethod(\n            function (keys) {\n                keysProcessed = 0;\n                keysCnt = keys.length;\n                if (keysCnt === 0) {\n                    migrated();\n                } else {\n                    for (i = 0; i < keysCnt; i++) {\n                        migrateKey(keys[i]);\n                    }\n                }\n            },\n            function () {\n            },\n            'keys',\n            []\n        );\n    }\n};\n\nSecureStorageBrowser = function (success, error, service) {\n    this.service = service;\n    setTimeout(success, 0);\n    return this;\n};\n\nSecureStorageBrowser.prototype = {\n\n    get: function (success, error, key) {\n        var value;\n        try {\n            _checkCallbacks(success, error);\n            value = localStorage.getItem('_SS_' + key);\n            if (!value) {\n                error(new Error('Key \"' + key + '\" not found.'));\n            } else {\n                success(value);\n            }\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    set: function (success, error, key, value) {\n        try {\n            _checkIsString(value);\n            _checkCallbacks(success, error);\n            localStorage.setItem('_SS_' + key, value);\n            success(key);\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    remove: function (success, error, key) {\n        localStorage.removeItem('_SS_' + key);\n        success(key);\n    },\n\n    keys: function (success, error) {\n        var i, len, key, keys = [];\n        try {\n            _checkCallbacks(success, error);\n            for (i = 0, len = localStorage.length; i < len; ++i) {\n                key = localStorage.key(i);\n                if ('_SS_' === key.slice(0, 4)) {\n                    keys.push(key.slice(4));\n                }\n            }\n            success(keys);\n        } catch (e) {\n            error(e);\n        }\n    },\n\n    clear: function (success, error) {\n        var i, key;\n        try {\n            _checkCallbacks(success, error);\n            i = localStorage.length;\n            while (i-- > 0) {\n                key = localStorage.key(i);\n                if (key && '_SS_' === key.slice(0, 4)) {\n                    localStorage.removeItem(key);\n                }\n            }\n            success();\n        } catch (e) {\n            error(e);\n        }\n    }\n};\n\nswitch (cordova.platformId) {\ncase 'ios':\n    SecureStorage = SecureStorageiOS;\n    break;\ncase 'android':\n    SecureStorage = SecureStorageAndroid;\n    break;\ncase 'windows':\n    SecureStorage = SecureStorageWindows;\n    break;\ncase 'browser':\n    SecureStorage = SecureStorageBrowser;\n    break;\ndefault:\n    SecureStorage = null;\n}\n\nif (!cordova.plugins) {\n    cordova.plugins = {};\n}\n\nif (!cordova.plugins.SecureStorage) {\n    cordova.plugins.SecureStorage = SecureStorage;\n}\n\nif (typeof module != 'undefined' && module.exports) {\n    module.exports = SecureStorage;\n}\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-secure-storage/node_modules/cordova-plugin-secure-storage/.eslintrc.js":"module.exports = {\n    \"env\": {\n        \"browser\": true,\n        \"jasmine\": true\n    },\n    \"globals\": {\n        \"cordova\": true,\n        \"module\": true,\n        \"exports\": true\n    },\n    \"extends\": \"eslint:recommended\",\n    \"rules\": {\n        \"indent\": [\n            \"error\",\n            4\n        ],\n        \"linebreak-style\": [\n            \"error\",\n            \"unix\"\n        ],\n        \"quotes\": [\n            \"warn\",\n            \"single\"\n        ],\n        \"semi\": [\n            \"error\",\n            \"always\"\n        ],\n        \"no-console\": [\n            \"warn\"\n        ],\n        \"no-multi-spaces\": [\n            \"error\"\n        ],\n        \"eqeqeq\": [\n            \"error\",\n            \"smart\"\n        ],\n        \"no-loop-func\": [\n            \"error\"\n        ],\n        \"no-param-reassign\": [\n            \"error\"\n        ],\n        \"vars-on-top\": [\n            \"warn\"\n        ],\n        \"no-use-before-define\": [\n            \"error\"\n        ],\n    }\n};","/home/travis/build/npmtest/node-npmtest-cordova-plugin-secure-storage/node_modules/cordova-plugin-secure-storage/www/sjcl_ss.js":"/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\"use strict\";\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/** @namespace The Stanford Javascript Crypto Library, top-level namespace. */\nvar sjcl = {\n  /** @namespace Symmetric ciphers. */\n  cipher: {},\n\n  /** @namespace Hash functions.  Right now only SHA256 is implemented. */\n  hash: {},\n\n  /** @namespace Key exchange functions.  Right now only SRP is implemented. */\n  keyexchange: {},\n\n  /** @namespace Block cipher modes of operation. */\n  mode: {},\n\n  /** @namespace Miscellaneous.  HMAC and PBKDF2. */\n  misc: {},\n\n  /**\n   * @namespace Bit array encoders and decoders.\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n\n  /** @namespace Exceptions. */\n  exception: {\n    /** @constructor Ciphertext is corrupt. */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n\n    /** @constructor Invalid parameter. */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n\n    /** @constructor Bug or missing feature in SJCL. @constructor */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /** @constructor Something isn't ready. */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n\nif(typeof module !== 'undefined' && module.exports){\n  module.exports = sjcl;\n}\n// Do not AMD define the module, as it might clash if sjcl is used in the cordova app\n// outside the plugin\n// if (typeof define === \"function\") {\n//     console.log('define')\n\n//     define([], function () {\n//         return sjcl;\n//     });\n// }\n\n/** @fileOverview Low-level AES implementation.\n *\n * This file contains a low-level implementation of AES, optimized for\n * size and for efficiency on several browsers.  It is based on\n * OpenSSL's aes_core.c, a public-domain implementation by Vincent\n * Rijmen, Antoon Bosselaers and Paulo Barreto.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Schedule out an AES key for both encryption and decryption.  This\n * is a low-level class.  Use a cipher mode to do bulk encryption.\n *\n * @constructor\n * @param {Array} key The key as an array of 4, 6 or 8 words.\n *\n * @class Advanced Encryption Standard (low-level interface)\n */\nsjcl.cipher.aes = function (key) {\n  if (!this._tables[0][0][0]) {\n    this._precompute();\n  }\n\n  var i, j, tmp,\n    encKey, decKey,\n    sbox = this._tables[0][4], decTable = this._tables[1],\n    keyLen = key.length, rcon = 1;\n\n  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n    throw new sjcl.exception.invalid(\"invalid aes key size\");\n  }\n\n  this._key = [encKey = key.slice(0), decKey = []];\n\n  // schedule encryption keys\n  for (i = keyLen; i < 4 * keyLen + 28; i++) {\n    tmp = encKey[i-1];\n\n    // apply sbox\n    if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {\n      tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];\n\n      // shift rows and add rcon\n      if (i%keyLen === 0) {\n        tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;\n        rcon = rcon<<1 ^ (rcon>>7)*283;\n      }\n    }\n\n    encKey[i] = encKey[i-keyLen] ^ tmp;\n  }\n\n  // schedule decryption keys\n  for (j = 0; i; j++, i--) {\n    tmp = encKey[j&3 ? i : i - 4];\n    if (i<=4 || j<4) {\n      decKey[j] = tmp;\n    } else {\n      decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^\n                  decTable[1][sbox[tmp>>16  & 255]] ^\n                  decTable[2][sbox[tmp>>8   & 255]] ^\n                  decTable[3][sbox[tmp      & 255]];\n    }\n  }\n};\n\nsjcl.cipher.aes.prototype = {\n  // public\n  /* Something like this might appear here eventually\n  name: \"AES\",\n  blockSize: 4,\n  keySizes: [4,6,8],\n  */\n\n  /**\n   * Encrypt an array of 4 big-endian words.\n   * @param {Array} data The plaintext.\n   * @return {Array} The ciphertext.\n   */\n  encrypt:function (data) { return this._crypt(data,0); },\n\n  /**\n   * Decrypt an array of 4 big-endian words.\n   * @param {Array} data The ciphertext.\n   * @return {Array} The plaintext.\n   */\n  decrypt:function (data) { return this._crypt(data,1); },\n\n  /**\n   * The expanded S-box and inverse S-box tables.  These will be computed\n   * on the client so that we don't have to send them down the wire.\n   *\n   * There are two tables, _tables[0] is for encryption and\n   * _tables[1] is for decryption.\n   *\n   * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n   * last (_tables[01][4]) is the S-box itself.\n   *\n   * @private\n   */\n  _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],\n\n  /**\n   * Expand the S-box tables.\n   *\n   * @private\n   */\n  _precompute: function () {\n   var encTable = this._tables[0], decTable = this._tables[1],\n       sbox = encTable[4], sboxInv = decTable[4],\n       i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;\n\n    // Compute double and third tables\n   for (i = 0; i < 256; i++) {\n     th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;\n   }\n\n   for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n     // Compute sbox\n     s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;\n     s = s>>8 ^ s&255 ^ 99;\n     sbox[x] = s;\n     sboxInv[s] = x;\n\n     // Compute MixColumns\n     x8 = d[x4 = d[x2 = d[x]]];\n     tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;\n     tEnc = d[s]*0x101 ^ s*0x1010100;\n\n     for (i = 0; i < 4; i++) {\n       encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;\n       decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;\n     }\n   }\n\n   // Compactify.  Considerable speedup on Firefox.\n   for (i = 0; i < 5; i++) {\n     encTable[i] = encTable[i].slice(0);\n     decTable[i] = decTable[i].slice(0);\n   }\n  },\n\n  /**\n   * Encryption and decryption core.\n   * @param {Array} input Four words to be encrypted or decrypted.\n   * @param dir The direction, 0 for encrypt and 1 for decrypt.\n   * @return {Array} The four encrypted or decrypted words.\n   * @private\n   */\n  _crypt:function (input, dir) {\n    if (input.length !== 4) {\n      throw new sjcl.exception.invalid(\"invalid aes block size\");\n    }\n\n    var key = this._key[dir],\n        // state variables a,b,c,d are loaded with pre-whitened data\n        a = input[0]           ^ key[0],\n        b = input[dir ? 3 : 1] ^ key[1],\n        c = input[2]           ^ key[2],\n        d = input[dir ? 1 : 3] ^ key[3],\n        a2, b2, c2,\n\n        nInnerRounds = key.length/4 - 2,\n        i,\n        kIndex = 4,\n        out = [0,0,0,0],\n        table = this._tables[dir],\n\n        // load up the tables\n        t0    = table[0],\n        t1    = table[1],\n        t2    = table[2],\n        t3    = table[3],\n        sbox  = table[4];\n\n    // Inner rounds.  Cribbed from OpenSSL.\n    for (i = 0; i < nInnerRounds; i++) {\n      a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];\n      b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];\n      c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];\n      d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];\n      kIndex += 4;\n      a=a2; b=b2; c=c2;\n    }\n\n    // Last round.\n    for (i = 0; i < 4; i++) {\n      out[dir ? 3&-i : i] =\n        sbox[a>>>24      ]<<24 ^\n        sbox[b>>16  & 255]<<16 ^\n        sbox[c>>8   & 255]<<8  ^\n        sbox[d      & 255]     ^\n        key[kIndex++];\n      a2=a; a=b; b=c; c=d; d=a2;\n    }\n\n    return out;\n  }\n};\n\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Arrays of bits, encoded as arrays of Numbers.\n *\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} length The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n\n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [0] _end Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n\n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n\n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n\n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  },\n\n  /** byteswap a word array inplace.\n   * (does not handle partial words)\n   * @param {sjcl.bitArray} a word array\n   * @return {sjcl.bitArray} byteswapped array\n   */\n  byteswapM: function(a) {\n    var i, v, m = 0xff00;\n    for (i = 0; i < a.length; ++i) {\n      v = a[i];\n      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n    }\n    return a;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace UTF-8 strings */\nsjcl.codec.utf8String = {\n  /** Convert from a bitArray to a UTF-8 string. */\n  fromBits: function (arr) {\n    var out = \"\", bl = sjcl.bitArray.bitLength(arr), i, tmp;\n    for (i=0; i<bl/8; i++) {\n      if ((i&3) === 0) {\n        tmp = arr[i/4];\n      }\n      out += String.fromCharCode(tmp >>> 24);\n      tmp <<= 8;\n    }\n    return decodeURIComponent(escape(out));\n  },\n\n  /** Convert from a UTF-8 string to a bitArray. */\n  toBits: function (str) {\n    str = unescape(encodeURIComponent(str));\n    var out = [], i, tmp=0;\n    for (i=0; i<str.length; i++) {\n      tmp = tmp << 8 | str.charCodeAt(i);\n      if ((i&3) === 3) {\n        out.push(tmp);\n        tmp = 0;\n      }\n    }\n    if (i&3) {\n      out.push(sjcl.bitArray.partial(8*(i&3), tmp));\n    }\n    return out;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Hexadecimal */\nsjcl.codec.hex = {\n  /** Convert from a bitArray to a hex string. */\n  fromBits: function (arr) {\n    var out = \"\", i;\n    for (i=0; i<arr.length; i++) {\n      out += ((arr[i]|0)+0xF00000000000).toString(16).substr(4);\n    }\n    return out.substr(0, sjcl.bitArray.bitLength(arr)/4);//.replace(/(.{8})/g, \"$1 \");\n  },\n  /** Convert from a hex string to a bitArray. */\n  toBits: function (str) {\n    var i, out=[], len;\n    str = str.replace(/\\s|0x/g, \"\");\n    len = str.length;\n    str = str + \"00000000\";\n    for (i=0; i<str.length; i+=8) {\n      out.push(parseInt(str.substr(i,8),16)^0);\n    }\n    return sjcl.bitArray.clamp(out, len*4);\n  }\n};\n\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Base64 encoding/decoding */\nsjcl.codec.base64 = {\n  /** The base64 alphabet.\n   * @private\n   */\n  _chars: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n\n  /** Convert from a bitArray to a base64 string. */\n  fromBits: function (arr, _noEquals, _url) {\n    var out = \"\", i, bits=0, c = sjcl.codec.base64._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);\n    if (_url) {\n      c = c.substr(0,62) + '-_';\n    }\n    for (i=0; out.length * 6 < bl; ) {\n      out += c.charAt((ta ^ arr[i]>>>bits) >>> 26);\n      if (bits < 6) {\n        ta = arr[i] << (6-bits);\n        bits += 26;\n        i++;\n      } else {\n        ta <<= 6;\n        bits -= 6;\n      }\n    }\n    while ((out.length & 3) && !_noEquals) { out += \"=\"; }\n    return out;\n  },\n\n  /** Convert from a base64 string to a bitArray */\n  toBits: function(str, _url) {\n    str = str.replace(/\\s|=/g,'');\n    var out = [], i, bits=0, c = sjcl.codec.base64._chars, ta=0, x;\n    if (_url) {\n      c = c.substr(0,62) + '-_';\n    }\n    for (i=0; i<str.length; i++) {\n      x = c.indexOf(str.charAt(i));\n      if (x < 0) {\n        throw new sjcl.exception.invalid(\"this isn't base64!\");\n      }\n      if (bits > 26) {\n        bits -= 26;\n        out.push(ta ^ x>>>bits);\n        ta  = x << (32-bits);\n      } else {\n        bits += 6;\n        ta ^= x << (32-bits);\n      }\n    }\n    if (bits&56) {\n      out.push(sjcl.bitArray.partial(bits&56, ta, 1));\n    }\n    return out;\n  }\n};\n\nsjcl.codec.base64url = {\n  fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr,1,1); },\n  toBits: function (str) { return sjcl.codec.base64.toBits(str,1); }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n * @class Secure Hash Algorithm, 256 bits.\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n\n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n\n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    for (i = 512+ol & -512; i <= nl; i+= 512) {\n      this._block(b.splice(0,16));\n    }\n    return this;\n  },\n\n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n\n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    outer: for (; i<64; prime++) {\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          // not a prime\n          continue outer;\n        }\n      }\n\n      if (i<8) {\n        this._init[i] = frac(Math.pow(prime, 1/2));\n      }\n      this._key[i] = frac(Math.pow(prime, 1/3));\n      i++;\n    }\n  },\n\n  /**\n   * Perform one cycle of SHA-256.\n   * @param {bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var i, tmp, a, b,\n      w = words.slice(0),\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) +\n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n\n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n\n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview CCM mode implementation.\n *\n * Special thanks to Roy Nicholson for pointing out a bug in our\n * implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace CTR mode with CBC MAC. */\nsjcl.mode.ccm = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"ccm\",\n\n  /** Encrypt in CCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @return {bitArray} The encrypted data, an array of bytes.\n   */\n  encrypt: function(prf, plaintext, iv, adata, tlen) {\n    var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;\n    tlen = tlen || 64;\n    adata = adata || [];\n\n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n\n    // compute the length of the length\n    for (L=2; L<4 && ol >>> 8*L; L++) {}\n    if (L < 15 - ivl) { L = 15-ivl; }\n    iv = w.clamp(iv,8*(15-L));\n\n    // compute the tag\n    tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);\n\n    // encrypt\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n\n    return w.concat(out.data, out.tag);\n  },\n\n  /** Decrypt in CCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [[]] adata The authenticated data.\n   * @param {Number} [64] tlen the desired tag length, in bits.\n   * @return {bitArray} The decrypted data.\n   */\n  decrypt: function(prf, ciphertext, iv, adata, tlen) {\n    tlen = tlen || 64;\n    adata = adata || [];\n    var L,\n        w=sjcl.bitArray,\n        ivl = w.bitLength(iv) / 8,\n        ol = w.bitLength(ciphertext),\n        out = w.clamp(ciphertext, ol - tlen),\n        tag = w.bitSlice(ciphertext, ol - tlen), tag2;\n\n\n    ol = (ol - tlen) / 8;\n\n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n\n    // compute the length of the length\n    for (L=2; L<4 && ol >>> 8*L; L++) {}\n    if (L < 15 - ivl) { L = 15-ivl; }\n    iv = w.clamp(iv,8*(15-L));\n\n    // decrypt\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n\n    // check the tag\n    tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);\n    if (!w.equal(out.tag, tag2)) {\n      throw new sjcl.exception.corrupt(\"ccm: tag doesn't match\");\n    }\n\n    return out.data;\n  },\n\n  /* Compute the (unencrypted) authentication tag, according to the CCM specification\n   * @param {Object} prf The pseudorandom function.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} adata The authenticated data.\n   * @param {Number} tlen the desired tag length, in bits.\n   * @return {bitArray} The tag, but not yet encrypted.\n   * @private\n   */\n  _computeTag: function(prf, plaintext, iv, adata, tlen, L) {\n    // compute B[0]\n    var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;\n\n    tlen /= 8;\n\n    // check tag length and message length\n    if (tlen % 2 || tlen < 4 || tlen > 16) {\n      throw new sjcl.exception.invalid(\"ccm: invalid tag length\");\n    }\n\n    if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {\n      // I don't want to deal with extracting high words from doubles.\n      throw new sjcl.exception.bug(\"ccm: can't deal with 4GiB or more data\");\n    }\n\n    // mac the flags\n    mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];\n\n    // mac the iv and length\n    mac = w.concat(mac, iv);\n    mac[3] |= w.bitLength(plaintext)/8;\n    mac = prf.encrypt(mac);\n\n\n    if (adata.length) {\n      // mac the associated data.  start with its length...\n      tmp = w.bitLength(adata)/8;\n      if (tmp <= 0xFEFF) {\n        macData = [w.partial(16, tmp)];\n      } else if (tmp <= 0xFFFFFFFF) {\n        macData = w.concat([w.partial(16,0xFFFE)], [tmp]);\n      } // else ...\n\n      // mac the data itself\n      macData = w.concat(macData, adata);\n      for (i=0; i<macData.length; i += 4) {\n        mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));\n      }\n    }\n\n    // mac the plaintext\n    for (i=0; i<plaintext.length; i+=4) {\n      mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));\n    }\n\n    return w.clamp(mac, tlen * 8);\n  },\n\n  /** CCM CTR mode.\n   * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.\n   * May mutate its arguments.\n   * @param {Object} prf The PRF.\n   * @param {bitArray} data The data to be encrypted or decrypted.\n   * @param {bitArray} iv The initialization vector.\n   * @param {bitArray} tag The authentication tag.\n   * @param {Number} tlen The length of th etag, in bits.\n   * @param {Number} L The CCM L value.\n   * @return {Object} An object with data and tag, the en/decryption of data and tag values.\n   * @private\n   */\n  _ctrMode: function(prf, data, iv, tag, tlen, L) {\n    var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data);\n\n    // start the ctr\n    ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);\n\n    // en/decrypt the tag\n    tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);\n\n    // en/decrypt the data\n    if (!l) { return {tag:tag, data:[]}; }\n\n    for (i=0; i<l; i+=4) {\n      ctr[3]++;\n      enc = prf.encrypt(ctr);\n      data[i]   ^= enc[0];\n      data[i+1] ^= enc[1];\n      data[i+2] ^= enc[2];\n      data[i+3] ^= enc[3];\n    }\n    return { tag:tag, data:w.clamp(data,bl) };\n  }\n};\n/** @fileOverview OCB 2.0 implementation\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace\n * Phil Rogaway's Offset CodeBook mode, version 2.0.\n * May be covered by US and international patents.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\nsjcl.mode.ocb2 = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"ocb2\",\n\n  /** Encrypt in OCB mode, version 2.0.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @param [false] premac 1 if the authentication data is pre-macced with PMAC.\n   * @return The encrypted data, an array of bytes.\n   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.\n   */\n  encrypt: function(prp, plaintext, iv, adata, tlen, premac) {\n    if (sjcl.bitArray.bitLength(iv) !== 128) {\n      throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    }\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = times2(prp.encrypt(iv)),\n        bi, bl,\n        output = [],\n        pad;\n\n    adata = adata || [];\n    tlen  = tlen || 64;\n\n    for (i=0; i+4 < plaintext.length; i+=4) {\n      /* Encrypt a non-final block */\n      bi = plaintext.slice(i,i+4);\n      checksum = xor(checksum, bi);\n      output = output.concat(xor(delta,prp.encrypt(xor(delta, bi))));\n      delta = times2(delta);\n    }\n\n    /* Chop out the final block */\n    bi = plaintext.slice(i);\n    bl = w.bitLength(bi);\n    pad = prp.encrypt(xor(delta,[0,0,0,bl]));\n    bi = w.clamp(xor(bi.concat([0,0,0]),pad), bl);\n\n    /* Checksum the final block, and finalize the checksum */\n    checksum = xor(checksum,xor(bi.concat([0,0,0]),pad));\n    checksum = prp.encrypt(xor(checksum,xor(delta,times2(delta))));\n\n    /* MAC the header */\n    if (adata.length) {\n      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));\n    }\n\n    return output.concat(w.concat(bi, w.clamp(checksum, tlen)));\n  },\n\n  /** Decrypt in OCB mode.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @param {boolean} [premac=false] true if the authentication data is pre-macced with PMAC.\n   * @return The decrypted data, an array of bytes.\n   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.\n   * @throws {sjcl.exception.corrupt} if if the message is corrupt.\n   */\n  decrypt: function(prp, ciphertext, iv, adata, tlen, premac) {\n    if (sjcl.bitArray.bitLength(iv) !== 128) {\n      throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    }\n    tlen  = tlen || 64;\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = times2(prp.encrypt(iv)),\n        bi, bl,\n        len = sjcl.bitArray.bitLength(ciphertext) - tlen,\n        output = [],\n        pad;\n\n    adata = adata || [];\n\n    for (i=0; i+4 < len/32; i+=4) {\n      /* Decrypt a non-final block */\n      bi = xor(delta, prp.decrypt(xor(delta, ciphertext.slice(i,i+4))));\n      checksum = xor(checksum, bi);\n      output = output.concat(bi);\n      delta = times2(delta);\n    }\n\n    /* Chop out and decrypt the final block */\n    bl = len-i*32;\n    pad = prp.encrypt(xor(delta,[0,0,0,bl]));\n    bi = xor(pad, w.clamp(ciphertext.slice(i),bl).concat([0,0,0]));\n\n    /* Checksum the final block, and finalize the checksum */\n    checksum = xor(checksum, bi);\n    checksum = prp.encrypt(xor(checksum, xor(delta, times2(delta))));\n\n    /* MAC the header */\n    if (adata.length) {\n      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));\n    }\n\n    if (!w.equal(w.clamp(checksum, tlen), w.bitSlice(ciphertext, len))) {\n      throw new sjcl.exception.corrupt(\"ocb: tag doesn't match\");\n    }\n\n    return output.concat(w.clamp(bi,bl));\n  },\n\n  /** PMAC authentication for OCB associated data.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} adata The authenticated data.\n   */\n  pmac: function(prp, adata) {\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = prp.encrypt([0,0,0,0]),\n        bi;\n\n    delta = xor(delta,times2(times2(delta)));\n\n    for (i=0; i+4<adata.length; i+=4) {\n      delta = times2(delta);\n      checksum = xor(checksum, prp.encrypt(xor(delta, adata.slice(i,i+4))));\n    }\n\n    bi = adata.slice(i);\n    if (w.bitLength(bi) < 128) {\n      delta = xor(delta,times2(delta));\n      bi = w.concat(bi,[0x80000000|0,0,0,0]);\n    }\n    checksum = xor(checksum, bi);\n    return prp.encrypt(xor(times2(xor(delta,times2(delta))), checksum));\n  },\n\n  /** Double a block of words, OCB style.\n   * @private\n   */\n  _times2: function(x) {\n    return [x[0]<<1 ^ x[1]>>>31,\n            x[1]<<1 ^ x[2]>>>31,\n            x[2]<<1 ^ x[3]>>>31,\n            x[3]<<1 ^ (x[0]>>>31)*0x87];\n  }\n};\n/** @fileOverview GCM mode implementation.\n *\n * @author Juho Vähä-Herttua\n */\n\n/** @namespace Galois/Counter mode. */\nsjcl.mode.gcm = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"gcm\",\n\n  /** Encrypt in GCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=128] The desired tag length, in bits.\n   * @return {bitArray} The encrypted data, an array of bytes.\n   */\n  encrypt: function (prf, plaintext, iv, adata, tlen) {\n    var out, data = plaintext.slice(0), w=sjcl.bitArray;\n    tlen = tlen || 128;\n    adata = adata || [];\n\n    // encrypt and tag\n    out = sjcl.mode.gcm._ctrMode(true, prf, data, adata, iv, tlen);\n\n    return w.concat(out.data, out.tag);\n  },\n\n  /** Decrypt in GCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=128] The desired tag length, in bits.\n   * @return {bitArray} The decrypted data.\n   */\n  decrypt: function (prf, ciphertext, iv, adata, tlen) {\n    var out, data = ciphertext.slice(0), tag, w=sjcl.bitArray, l=w.bitLength(data);\n    tlen = tlen || 128;\n    adata = adata || [];\n\n    // Slice tag out of data\n    if (tlen <= l) {\n      tag = w.bitSlice(data, l-tlen);\n      data = w.bitSlice(data, 0, l-tlen);\n    } else {\n      tag = data;\n      data = [];\n    }\n\n    // decrypt and tag\n    out = sjcl.mode.gcm._ctrMode(false, prf, data, adata, iv, tlen);\n\n    if (!w.equal(out.tag, tag)) {\n      throw new sjcl.exception.corrupt(\"gcm: tag doesn't match\");\n    }\n    return out.data;\n  },\n\n  /* Compute the galois multiplication of X and Y\n   * @private\n   */\n  _galoisMultiply: function (x, y) {\n    var i, j, xi, Zi, Vi, lsb_Vi, w=sjcl.bitArray, xor=w._xor4;\n\n    Zi = [0,0,0,0];\n    Vi = y.slice(0);\n\n    // Block size is 128 bits, run 128 times to get Z_128\n    for (i=0; i<128; i++) {\n      xi = (x[Math.floor(i/32)] & (1 << (31-i%32))) !== 0;\n      if (xi) {\n        // Z_i+1 = Z_i ^ V_i\n        Zi = xor(Zi, Vi);\n      }\n\n      // Store the value of LSB(V_i)\n      lsb_Vi = (Vi[3] & 1) !== 0;\n\n      // V_i+1 = V_i >> 1\n      for (j=3; j>0; j--) {\n        Vi[j] = (Vi[j] >>> 1) | ((Vi[j-1]&1) << 31);\n      }\n      Vi[0] = Vi[0] >>> 1;\n\n      // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R\n      if (lsb_Vi) {\n        Vi[0] = Vi[0] ^ (0xe1 << 24);\n      }\n    }\n    return Zi;\n  },\n\n  _ghash: function(H, Y0, data) {\n    var Yi, i, l = data.length;\n\n    Yi = Y0.slice(0);\n    for (i=0; i<l; i+=4) {\n      Yi[0] ^= 0xffffffff&data[i];\n      Yi[1] ^= 0xffffffff&data[i+1];\n      Yi[2] ^= 0xffffffff&data[i+2];\n      Yi[3] ^= 0xffffffff&data[i+3];\n      Yi = sjcl.mode.gcm._galoisMultiply(Yi, H);\n    }\n    return Yi;\n  },\n\n  /** GCM CTR mode.\n   * Encrypt or decrypt data and tag with the prf in GCM-style CTR mode.\n   * @param {Boolean} encrypt True if encrypt, false if decrypt.\n   * @param {Object} prf The PRF.\n   * @param {bitArray} data The data to be encrypted or decrypted.\n   * @param {bitArray} iv The initialization vector.\n   * @param {bitArray} adata The associated data to be tagged.\n   * @param {Number} tlen The length of the tag, in bits.\n   */\n  _ctrMode: function(encrypt, prf, data, adata, iv, tlen) {\n    var H, J0, S0, enc, i, ctr, tag, last, l, bl, abl, ivbl, w=sjcl.bitArray;\n\n    // Calculate data lengths\n    l = data.length;\n    bl = w.bitLength(data);\n    abl = w.bitLength(adata);\n    ivbl = w.bitLength(iv);\n\n    // Calculate the parameters\n    H = prf.encrypt([0,0,0,0]);\n    if (ivbl === 96) {\n      J0 = iv.slice(0);\n      J0 = w.concat(J0, [1]);\n    } else {\n      J0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], iv);\n      J0 = sjcl.mode.gcm._ghash(H, J0, [0,0,Math.floor(ivbl/0x100000000),ivbl&0xffffffff]);\n    }\n    S0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], adata);\n\n    // Initialize ctr and tag\n    ctr = J0.slice(0);\n    tag = S0.slice(0);\n\n    // If decrypting, calculate hash\n    if (!encrypt) {\n      tag = sjcl.mode.gcm._ghash(H, S0, data);\n    }\n\n    // Encrypt all the data\n    for (i=0; i<l; i+=4) {\n       ctr[3]++;\n       enc = prf.encrypt(ctr);\n       data[i]   ^= enc[0];\n       data[i+1] ^= enc[1];\n       data[i+2] ^= enc[2];\n       data[i+3] ^= enc[3];\n    }\n    data = w.clamp(data, bl);\n\n    // If encrypting, calculate hash\n    if (encrypt) {\n      tag = sjcl.mode.gcm._ghash(H, S0, data);\n    }\n\n    // Calculate last block from bit lengths, ugly because bitwise operations are 32-bit\n    last = [\n      Math.floor(abl/0x100000000), abl&0xffffffff,\n      Math.floor(bl/0x100000000), bl&0xffffffff\n    ];\n\n    // Calculate the final tag block\n    tag = sjcl.mode.gcm._ghash(H, tag, last);\n    enc = prf.encrypt(J0);\n    tag[0] ^= enc[0];\n    tag[1] ^= enc[1];\n    tag[2] ^= enc[2];\n    tag[3] ^= enc[3];\n\n    return { tag:w.bitSlice(tag, 0, tlen), data:data };\n  }\n};\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n\n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n\n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};/** @fileOverview Password-based key-derivation function, version 2.0.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** Password-Based Key-Derivation Function, version 2.0.\n *\n * Generate keys from passwords using PBKDF2-HMAC-SHA256.\n *\n * This is the method specified by RSA's PKCS #5 standard.\n *\n * @param {bitArray|String} password  The password.\n * @param {bitArray|String} salt The salt.  Should have lots of entropy.\n * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.\n * @param {Number} [length] The length of the derived key.  Defaults to the\n                            output size of the hash function.\n * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.\n * @return {bitArray} the derived key.\n */\nsjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {\n  count = count || 1000;\n\n  if (length < 0 || count < 0) {\n    throw sjcl.exception.invalid(\"invalid params to pbkdf2\");\n  }\n\n  if (typeof password === \"string\") {\n    password = sjcl.codec.utf8String.toBits(password);\n  }\n\n  if (typeof salt === \"string\") {\n    salt = sjcl.codec.utf8String.toBits(salt);\n  }\n\n  Prff = Prff || sjcl.misc.hmac;\n\n  var prf = new Prff(password),\n      u, ui, i, j, k, out = [], b = sjcl.bitArray;\n\n  for (k = 1; 32 * out.length < (length || 1); k++) {\n    u = ui = prf.encrypt(b.concat(salt,[k]));\n\n    for (i=1; i<count; i++) {\n      ui = prf.encrypt(ui);\n      for (j=0; j<ui.length; j++) {\n        u[j] ^= ui[j];\n      }\n    }\n\n    out = out.concat(u);\n  }\n\n  if (length) { out = b.clamp(out, length); }\n\n  return out;\n};\n/** @fileOverview Random number generator.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Michael Brooks\n */\n\n/** @constructor\n * @class Random number generator\n * @description\n * <b>Use sjcl.random as a singleton for this class!</b>\n * <p>\n * This random number generator is a derivative of Ferguson and Schneier's\n * generator Fortuna.  It collects entropy from various events into several\n * pools, implemented by streaming SHA-256 instances.  It differs from\n * ordinary Fortuna in a few ways, though.\n * </p>\n *\n * <p>\n * Most importantly, it has an entropy estimator.  This is present because\n * there is a strong conflict here between making the generator available\n * as soon as possible, and making sure that it doesn't \"run on empty\".\n * In Fortuna, there is a saved state file, and the system is likely to have\n * time to warm up.\n * </p>\n *\n * <p>\n * Second, because users are unlikely to stay on the page for very long,\n * and to speed startup time, the number of pools increases logarithmically:\n * a new pool is created when the previous one is actually used for a reseed.\n * This gives the same asymptotic guarantees as Fortuna, but gives more\n * entropy to early reseeds.\n * </p>\n *\n * <p>\n * The entire mechanism here feels pretty klunky.  Furthermore, there are\n * several improvements that should be made, including support for\n * dedicated cryptographic functions that may be present in some browsers;\n * state files in local storage; cookies containing randomness; etc.  So\n * look for improvements in future versions.\n * </p>\n */\nsjcl.prng = function(defaultParanoia) {\n\n  /* private */\n  this._pools                   = [new sjcl.hash.sha256()];\n  this._poolEntropy             = [0];\n  this._reseedCount             = 0;\n  this._robins                  = {};\n  this._eventId                 = 0;\n\n  this._collectorIds            = {};\n  this._collectorIdNext         = 0;\n\n  this._strength                = 0;\n  this._poolStrength            = 0;\n  this._nextReseed              = 0;\n  this._key                     = [0,0,0,0,0,0,0,0];\n  this._counter                 = [0,0,0,0];\n  this._cipher                  = undefined;\n  this._defaultParanoia         = defaultParanoia;\n\n  /* event listener stuff */\n  this._collectorsStarted       = false;\n  this._callbacks               = {progress: {}, seeded: {}};\n  this._callbackI               = 0;\n\n  /* constants */\n  this._NOT_READY               = 0;\n  this._READY                   = 1;\n  this._REQUIRES_RESEED         = 2;\n\n  this._MAX_WORDS_PER_BURST     = 65536;\n  this._PARANOIA_LEVELS         = [0,48,64,96,128,192,256,384,512,768,1024];\n  this._MILLISECONDS_PER_RESEED = 30000;\n  this._BITS_PER_RESEED         = 80;\n};\n\nsjcl.prng.prototype = {\n  /** Generate several random words, and return them in an array.\n   * A word consists of 32 bits (4 bytes)\n   * @param {Number} nwords The number of words to generate.\n   */\n  randomWords: function (nwords, paranoia) {\n    var out = [], i, readiness = this.isReady(paranoia), g;\n\n    if (readiness === this._NOT_READY) {\n      throw new sjcl.exception.notReady(\"generator isn't seeded\");\n    } else if (readiness & this._REQUIRES_RESEED) {\n      this._reseedFromPools(!(readiness & this._READY));\n    }\n\n    for (i=0; i<nwords; i+= 4) {\n      if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {\n        this._gate();\n      }\n\n      g = this._gen4words();\n      out.push(g[0],g[1],g[2],g[3]);\n    }\n    this._gate();\n\n    return out.slice(0,nwords);\n  },\n\n  setDefaultParanoia: function (paranoia, allowZeroParanoia) {\n    if (paranoia === 0 && allowZeroParanoia !== \"Setting paranoia=0 will ruin your security; use it only for testing\") {\n      throw \"Setting paranoia=0 will ruin your security; use it only for testing\";\n    }\n\n    this._defaultParanoia = paranoia;\n  },\n\n  /**\n   * Add entropy to the pools.\n   * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string\n   * @param {Number} estimatedEntropy The estimated entropy of data, in bits\n   * @param {String} source The source of the entropy, eg \"mouse\"\n   */\n  addEntropy: function (data, estimatedEntropy, source) {\n    source = source || \"user\";\n\n    var id,\n      i, tmp,\n      t = (new Date()).valueOf(),\n      robin = this._robins[source],\n      oldReady = this.isReady(), err = 0, objName;\n\n    id = this._collectorIds[source];\n    if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }\n\n    if (robin === undefined) { robin = this._robins[source] = 0; }\n    this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;\n\n    switch(typeof(data)) {\n\n    case \"number\":\n      if (estimatedEntropy === undefined) {\n        estimatedEntropy = 1;\n      }\n      this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);\n      break;\n\n    case \"object\":\n      objName = Object.prototype.toString.call(data);\n      if (objName === \"[object Uint32Array]\") {\n        tmp = [];\n        for (i = 0; i < data.length; i++) {\n          tmp.push(data[i]);\n        }\n        data = tmp;\n      } else {\n        if (objName !== \"[object Array]\") {\n          err = 1;\n        }\n        for (i=0; i<data.length && !err; i++) {\n          if (typeof(data[i]) !== \"number\") {\n            err = 1;\n          }\n        }\n      }\n      if (!err) {\n        if (estimatedEntropy === undefined) {\n          /* horrible entropy estimator */\n          estimatedEntropy = 0;\n          for (i=0; i<data.length; i++) {\n            tmp= data[i];\n            while (tmp>0) {\n              estimatedEntropy++;\n              tmp = tmp >>> 1;\n            }\n          }\n        }\n        this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));\n      }\n      break;\n\n    case \"string\":\n      if (estimatedEntropy === undefined) {\n       /* English text has just over 1 bit per character of entropy.\n        * But this might be HTML or something, and have far less\n        * entropy than English...  Oh well, let's just say one bit.\n        */\n       estimatedEntropy = data.length;\n      }\n      this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);\n      this._pools[robin].update(data);\n      break;\n\n    default:\n      err=1;\n    }\n    if (err) {\n      throw new sjcl.exception.bug(\"random: addEntropy only supports number, array of numbers or string\");\n    }\n\n    /* record the new strength */\n    this._poolEntropy[robin] += estimatedEntropy;\n    this._poolStrength += estimatedEntropy;\n\n    /* fire off events */\n    if (oldReady === this._NOT_READY) {\n      if (this.isReady() !== this._NOT_READY) {\n        this._fireEvent(\"seeded\", Math.max(this._strength, this._poolStrength));\n      }\n      this._fireEvent(\"progress\", this.getProgress());\n    }\n  },\n\n  /** Is the generator ready? */\n  isReady: function (paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];\n\n    if (this._strength && this._strength >= entropyRequired) {\n      return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?\n        this._REQUIRES_RESEED | this._READY :\n        this._READY;\n    } else {\n      return (this._poolStrength >= entropyRequired) ?\n        this._REQUIRES_RESEED | this._NOT_READY :\n        this._NOT_READY;\n    }\n  },\n\n  /** Get the generator's progress toward readiness, as a fraction */\n  getProgress: function (paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];\n\n    if (this._strength >= entropyRequired) {\n      return 1.0;\n    } else {\n      return (this._poolStrength > entropyRequired) ?\n        1.0 :\n        this._poolStrength / entropyRequired;\n    }\n  },\n\n  /** start the built-in entropy collectors */\n  startCollectors: function () {\n    if (this._collectorsStarted) { return; }\n\n    this._eventListener = {\n      loadTimeCollector: this._bind(this._loadTimeCollector),\n      mouseCollector: this._bind(this._mouseCollector),\n      keyboardCollector: this._bind(this._keyboardCollector),\n      accelerometerCollector: this._bind(this._accelerometerCollector),\n      touchCollector: this._bind(this._touchCollector)\n    };\n\n    if (window.addEventListener) {\n      window.addEventListener(\"load\", this._eventListener.loadTimeCollector, false);\n      window.addEventListener(\"mousemove\", this._eventListener.mouseCollector, false);\n      window.addEventListener(\"keypress\", this._eventListener.keyboardCollector, false);\n      window.addEventListener(\"devicemotion\", this._eventListener.accelerometerCollector, false);\n      window.addEventListener(\"touchmove\", this._eventListener.touchCollector, false);\n    } else if (document.attachEvent) {\n      document.attachEvent(\"onload\", this._eventListener.loadTimeCollector);\n      document.attachEvent(\"onmousemove\", this._eventListener.mouseCollector);\n      document.attachEvent(\"keypress\", this._eventListener.keyboardCollector);\n    } else {\n      throw new sjcl.exception.bug(\"can't attach event\");\n    }\n\n    this._collectorsStarted = true;\n  },\n\n  /** stop the built-in entropy collectors */\n  stopCollectors: function () {\n    if (!this._collectorsStarted) { return; }\n\n    if (window.removeEventListener) {\n      window.removeEventListener(\"load\", this._eventListener.loadTimeCollector, false);\n      window.removeEventListener(\"mousemove\", this._eventListener.mouseCollector, false);\n      window.removeEventListener(\"keypress\", this._eventListener.keyboardCollector, false);\n      window.removeEventListener(\"devicemotion\", this._eventListener.accelerometerCollector, false);\n      window.removeEventListener(\"touchmove\", this._eventListener.touchCollector, false);\n    } else if (document.detachEvent) {\n      document.detachEvent(\"onload\", this._eventListener.loadTimeCollector);\n      document.detachEvent(\"onmousemove\", this._eventListener.mouseCollector);\n      document.detachEvent(\"keypress\", this._eventListener.keyboardCollector);\n    }\n\n    this._collectorsStarted = false;\n  },\n\n  /* use a cookie to store entropy.\n  useCookie: function (all_cookies) {\n      throw new sjcl.exception.bug(\"random: useCookie is unimplemented\");\n  },*/\n\n  /** add an event listener for progress or seeded-ness. */\n  addEventListener: function (name, callback) {\n    this._callbacks[name][this._callbackI++] = callback;\n  },\n\n  /** remove an event listener for progress or seeded-ness */\n  removeEventListener: function (name, cb) {\n    var i, j, cbs=this._callbacks[name], jsTemp=[];\n\n    /* I'm not sure if this is necessary; in C++, iterating over a\n     * collection and modifying it at the same time is a no-no.\n     */\n\n    for (j in cbs) {\n      if (cbs.hasOwnProperty(j) && cbs[j] === cb) {\n        jsTemp.push(j);\n      }\n    }\n\n    for (i=0; i<jsTemp.length; i++) {\n      j = jsTemp[i];\n      delete cbs[j];\n    }\n  },\n\n  _bind: function (func) {\n    var that = this;\n    return function () {\n      func.apply(that, arguments);\n    };\n  },\n\n  /** Generate 4 random words, no reseed, no gate.\n   * @private\n   */\n  _gen4words: function () {\n    for (var i=0; i<4; i++) {\n      this._counter[i] = this._counter[i]+1 | 0;\n      if (this._counter[i]) { break; }\n    }\n    return this._cipher.encrypt(this._counter);\n  },\n\n  /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.\n   * @private\n   */\n  _gate: function () {\n    this._key = this._gen4words().concat(this._gen4words());\n    this._cipher = new sjcl.cipher.aes(this._key);\n  },\n\n  /** Reseed the generator with the given words\n   * @private\n   */\n  _reseed: function (seedWords) {\n    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));\n    this._cipher = new sjcl.cipher.aes(this._key);\n    for (var i=0; i<4; i++) {\n      this._counter[i] = this._counter[i]+1 | 0;\n      if (this._counter[i]) { break; }\n    }\n  },\n\n  /** reseed the data from the entropy pools\n   * @param full If set, use all the entropy pools in the reseed.\n   */\n  _reseedFromPools: function (full) {\n    var reseedData = [], strength = 0, i;\n\n    this._nextReseed = reseedData[0] =\n      (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;\n\n    for (i=0; i<16; i++) {\n      /* On some browsers, this is cryptographically random.  So we might\n       * as well toss it in the pot and stir...\n       */\n      reseedData.push(Math.random()*0x100000000|0);\n    }\n\n    for (i=0; i<this._pools.length; i++) {\n     reseedData = reseedData.concat(this._pools[i].finalize());\n     strength += this._poolEntropy[i];\n     this._poolEntropy[i] = 0;\n\n     if (!full && (this._reseedCount & (1<<i))) { break; }\n    }\n\n    /* if we used the last pool, push a new one onto the stack */\n    if (this._reseedCount >= 1 << this._pools.length) {\n     this._pools.push(new sjcl.hash.sha256());\n     this._poolEntropy.push(0);\n    }\n\n    /* how strong was this reseed? */\n    this._poolStrength -= strength;\n    if (strength > this._strength) {\n      this._strength = strength;\n    }\n\n    this._reseedCount ++;\n    this._reseed(reseedData);\n  },\n\n  _keyboardCollector: function () {\n    this._addCurrentTimeToEntropy(1);\n  },\n\n  _mouseCollector: function (ev) {\n    var x, y;\n\n    try {\n      x = ev.x || ev.clientX || ev.offsetX || 0;\n      y = ev.y || ev.clientY || ev.offsetY || 0;\n    } catch (err) {\n      // Event originated from a secure element. No mouse position available.\n      x = 0;\n      y = 0;\n    }\n\n    if (x != 0 && y!= 0) {\n      sjcl.random.addEntropy([x,y], 2, \"mouse\");\n    }\n\n    this._addCurrentTimeToEntropy(0);\n  },\n\n  _touchCollector: function(ev) {\n    var touch = ev.touches[0] || ev.changedTouches[0];\n    var x = touch.pageX || touch.clientX,\n        y = touch.pageY || touch.clientY;\n\n    sjcl.random.addEntropy([x,y],1,\"touch\");\n\n    this._addCurrentTimeToEntropy(0);\n  },\n\n  _loadTimeCollector: function () {\n    this._addCurrentTimeToEntropy(2);\n  },\n\n  _addCurrentTimeToEntropy: function (estimatedEntropy) {\n    if (typeof window !== 'undefined' && window.performance && typeof window.performance.now === \"function\") {\n      //how much entropy do we want to add here?\n      sjcl.random.addEntropy(window.performance.now(), estimatedEntropy, \"loadtime\");\n    } else {\n      sjcl.random.addEntropy((new Date()).valueOf(), estimatedEntropy, \"loadtime\");\n    }\n  },\n  _accelerometerCollector: function (ev) {\n    var ac = ev.accelerationIncludingGravity.x||ev.accelerationIncludingGravity.y||ev.accelerationIncludingGravity.z;\n    if(window.orientation){\n      var or = window.orientation;\n      if (typeof or === \"number\") {\n        sjcl.random.addEntropy(or, 1, \"accelerometer\");\n      }\n    }\n    if (ac) {\n      sjcl.random.addEntropy(ac, 2, \"accelerometer\");\n    }\n    this._addCurrentTimeToEntropy(0);\n  },\n\n  _fireEvent: function (name, arg) {\n    var j, cbs=sjcl.random._callbacks[name], cbsTemp=[];\n    /* TODO: there is a race condition between removing collectors and firing them */\n\n    /* I'm not sure if this is necessary; in C++, iterating over a\n     * collection and modifying it at the same time is a no-no.\n     */\n\n    for (j in cbs) {\n      if (cbs.hasOwnProperty(j)) {\n        cbsTemp.push(cbs[j]);\n      }\n    }\n\n    for (j=0; j<cbsTemp.length; j++) {\n      cbsTemp[j](arg);\n    }\n  }\n};\n\n/** an instance for the prng.\n* @see sjcl.prng\n*/\nsjcl.random = new sjcl.prng(6);\n\n(function(){\n  // function for getting nodejs crypto module. catches and ignores errors.\n  function getCryptoModule() {\n    // return require('crypto'); // it will cause browserify package a huge node-crypto polyfill into the cordova.js bundle\n    return null;\n  }\n\n  try {\n    var buf, crypt, ab;\n\n    // get cryptographically strong entropy depending on runtime environment\n    if (typeof module !== 'undefined' && module.exports && (crypt = getCryptoModule()) && crypt.randomBytes) {\n      buf = crypt.randomBytes(1024/8);\n      buf = new Uint32Array(new Uint8Array(buf).buffer);\n      sjcl.random.addEntropy(buf, 1024, \"crypto.randomBytes\");\n\n    } else if (typeof window !== 'undefined' && typeof Uint32Array !== 'undefined') {\n      ab = new Uint32Array(32);\n      if (window.crypto && window.crypto.getRandomValues) {\n        window.crypto.getRandomValues(ab);\n      } else if (window.msCrypto && window.msCrypto.getRandomValues) {\n        window.msCrypto.getRandomValues(ab);\n      } else {\n        return;\n      }\n\n      // get cryptographically strong entropy in Webkit\n      sjcl.random.addEntropy(ab, 1024, \"crypto.getRandomValues\");\n\n    } else {\n      // no getRandomValues :-(\n    }\n  } catch (e) {\n    if (typeof window !== 'undefined' && window.console) {\n      console.log(\"There was an error collecting entropy from the browser:\");\n      console.log(e);\n      //we do not want the library to fail due to randomness not being maintained.\n    }\n  }\n}());\n/** @fileOverview Convenince functions centered around JSON encapsulation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n /** @namespace JSON encapsulation */\n sjcl.json = {\n  /** Default values for encryption */\n  defaults: { v:1, iter:1000, ks:128, ts:64, mode:\"ccm\", adata:\"\", cipher:\"aes\" },\n\n  /** Simple encryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} plaintext The data to encrypt.\n   * @param {Object} [params] The parameters including tag, iv and salt.\n   * @param {Object} [rp] A returned version with filled-in parameters.\n   * @return {Object} The cipher raw data.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   */\n  _encrypt: function (password, plaintext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n\n    var j = sjcl.json, p = j._add({ iv: sjcl.random.randomWords(4,0) },\n                                  j.defaults), tmp, prp, adata;\n    j._add(p, params);\n    adata = p.adata;\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n\n    if (!sjcl.mode[p.mode] ||\n        !sjcl.cipher[p.cipher] ||\n        (typeof password === \"string\" && p.iter <= 100) ||\n        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n        (p.iv.length < 2 || p.iv.length > 4)) {\n      throw new sjcl.exception.invalid(\"json encrypt: invalid parameters\");\n    }\n\n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0,p.ks/32);\n      p.salt = tmp.salt;\n    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.publicKey) {\n      tmp = password.kem();\n      p.kemtag = tmp.tag;\n      password = tmp.key.slice(0,p.ks/32);\n    }\n    if (typeof plaintext === \"string\") {\n      plaintext = sjcl.codec.utf8String.toBits(plaintext);\n    }\n    if (typeof adata === \"string\") {\n      p.adata = adata = sjcl.codec.utf8String.toBits(adata);\n    }\n    prp = new sjcl.cipher[p.cipher](password);\n\n    /* return the json data */\n    j._add(rp, p);\n    rp.key = password;\n\n    /* do the encryption */\n    p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);\n\n    //return j.encode(j._subtract(p, j.defaults));\n    return p;\n  },\n\n  /** Simple encryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} plaintext The data to encrypt.\n   * @param {Object} [params] The parameters including tag, iv and salt.\n   * @param {Object} [rp] A returned version with filled-in parameters.\n   * @return {String} The ciphertext serialized data.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   */\n  encrypt: function (password, plaintext, params, rp) {\n    var j = sjcl.json, p = j._encrypt.apply(j, arguments);\n    return j.encode(p);\n  },\n\n  /** Simple decryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {Object} ciphertext The cipher raw data to decrypt.\n   * @param {Object} [params] Additional non-default parameters.\n   * @param {Object} [rp] A returned object with filled parameters.\n   * @return {String} The plaintext.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.\n   */\n  _decrypt: function (password, ciphertext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n\n    var j = sjcl.json, p = j._add(j._add(j._add({},j.defaults),ciphertext), params, true), ct, tmp, prp, adata=p.adata;\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n\n    if (!sjcl.mode[p.mode] ||\n        !sjcl.cipher[p.cipher] ||\n        (typeof password === \"string\" && p.iter <= 100) ||\n        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n        (!p.iv) ||\n        (p.iv.length < 2 || p.iv.length > 4)) {\n      throw new sjcl.exception.invalid(\"json decrypt: invalid parameters\");\n    }\n\n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0,p.ks/32);\n      p.salt  = tmp.salt;\n    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.secretKey) {\n      password = password.unkem(sjcl.codec.base64.toBits(p.kemtag)).slice(0,p.ks/32);\n    }\n    if (typeof adata === \"string\") {\n      adata = sjcl.codec.utf8String.toBits(adata);\n    }\n    prp = new sjcl.cipher[p.cipher](password);\n\n    /* do the decryption */\n    ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);\n\n    /* return the json data */\n    j._add(rp, p);\n    rp.key = password;\n\n    if (params.raw === 1) {\n      return ct;\n    } else {\n      return sjcl.codec.utf8String.fromBits(ct);\n    }\n  },\n\n  /** Simple decryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} ciphertext The ciphertext to decrypt.\n   * @param {Object} [params] Additional non-default parameters.\n   * @param {Object} [rp] A returned object with filled parameters.\n   * @return {String} The plaintext.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.\n   */\n  decrypt: function (password, ciphertext, params, rp) {\n    var j = sjcl.json;\n    return j._decrypt(password, j.decode(ciphertext), params, rp);\n  },\n\n  /** Encode a flat structure into a JSON string.\n   * @param {Object} obj The structure to encode.\n   * @return {String} A JSON string.\n   * @throws {sjcl.exception.invalid} if obj has a non-alphanumeric property.\n   * @throws {sjcl.exception.bug} if a parameter has an unsupported type.\n   */\n  encode: function (obj) {\n    var i, out='{', comma='';\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        if (!i.match(/^[a-z0-9]+$/i)) {\n          throw new sjcl.exception.invalid(\"json encode: invalid property name\");\n        }\n        out += comma + '\"' + i + '\":';\n        comma = ',';\n\n        switch (typeof obj[i]) {\n          case 'number':\n          case 'boolean':\n            out += obj[i];\n            break;\n\n          case 'string':\n            out += '\"' + escape(obj[i]) + '\"';\n            break;\n\n          case 'object':\n            out += '\"' + sjcl.codec.base64.fromBits(obj[i],0) + '\"';\n            break;\n\n          default:\n            throw new sjcl.exception.bug(\"json encode: unsupported type\");\n        }\n      }\n    }\n    return out+'}';\n  },\n\n  /** Decode a simple (flat) JSON string into a structure.  The ciphertext,\n   * adata, salt and iv will be base64-decoded.\n   * @param {String} str The string.\n   * @return {Object} The decoded structure.\n   * @throws {sjcl.exception.invalid} if str isn't (simple) JSON.\n   */\n  decode: function (str) {\n    str = str.replace(/\\s/g,'');\n    if (!str.match(/^\\{.*\\}$/)) {\n      throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n    }\n    var a = str.replace(/^\\{|\\}$/g, '').split(/,/), out={}, i, m;\n    for (i=0; i<a.length; i++) {\n      if (!(m=a[i].match(/^\\s*(?:([\"']?)([a-z][a-z0-9]*)\\1)\\s*:\\s*(?:(-?\\d+)|\"([a-z0-9+\\/%*_.@=\\-]*)\"|(true|false))$/i))) {\n        throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n      }\n      if (m[3]) {\n        out[m[2]] = parseInt(m[3],10);\n      } else if (m[4]) {\n        out[m[2]] = m[2].match(/^(ct|adata|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);\n      } else if (m[5]) {\n        out[m[2]] = m[5] === 'true';\n      }\n    }\n    return out;\n  },\n\n  /** Insert all elements of src into target, modifying and returning target.\n   * @param {Object} target The object to be modified.\n   * @param {Object} src The object to pull data from.\n   * @param {boolean} [requireSame=false] If true, throw an exception if any field of target differs from corresponding field of src.\n   * @return {Object} target.\n   * @private\n   */\n  _add: function (target, src, requireSame) {\n    if (target === undefined) { target = {}; }\n    if (src === undefined) { return target; }\n    var i;\n    for (i in src) {\n      if (src.hasOwnProperty(i)) {\n        if (requireSame && target[i] !== undefined && target[i] !== src[i]) {\n          throw new sjcl.exception.invalid(\"required parameter overridden\");\n        }\n        target[i] = src[i];\n      }\n    }\n    return target;\n  },\n\n  /** Remove all elements of minus from plus.  Does not modify plus.\n   * @private\n   */\n  _subtract: function (plus, minus) {\n    var out = {}, i;\n\n    for (i in plus) {\n      if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {\n        out[i] = plus[i];\n      }\n    }\n\n    return out;\n  },\n\n  /** Return only the specified elements of src.\n   * @private\n   */\n  _filter: function (src, filter) {\n    var out = {}, i;\n    for (i=0; i<filter.length; i++) {\n      if (src[filter[i]] !== undefined) {\n        out[filter[i]] = src[filter[i]];\n      }\n    }\n    return out;\n  }\n};\n\n/** Simple encryption function; convenient shorthand for sjcl.json.encrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} plaintext The data to encrypt.\n * @param {Object} [params] The parameters including tag, iv and salt.\n * @param {Object} [rp] A returned version with filled-in parameters.\n * @return {String} The ciphertext.\n */\nsjcl.encrypt = sjcl.json.encrypt;\n\n/** Simple decryption function; convenient shorthand for sjcl.json.decrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} ciphertext The ciphertext to decrypt.\n * @param {Object} [params] Additional non-default parameters.\n * @param {Object} [rp] A returned object with filled parameters.\n * @return {String} The plaintext.\n */\nsjcl.decrypt = sjcl.json.decrypt;\n\n/** The cache for cachedPbkdf2.\n * @private\n */\nsjcl.misc._pbkdf2Cache = {};\n\n/** Cached PBKDF2 key derivation.\n * @param {String} password The password.\n * @param {Object} [obj] The derivation params (iteration count and optional salt).\n * @return {Object} The derived data in key, the salt in salt.\n */\nsjcl.misc.cachedPbkdf2 = function (password, obj) {\n  var cache = sjcl.misc._pbkdf2Cache, c, cp, str, salt, iter;\n\n  obj = obj || {};\n  iter = obj.iter || 1000;\n\n  /* open the cache for this password and iteration count */\n  cp = cache[password] = cache[password] || {};\n  c = cp[iter] = cp[iter] || { firstSalt: (obj.salt && obj.salt.length) ?\n                     obj.salt.slice(0) : sjcl.random.randomWords(2,0) };\n\n  salt = (obj.salt === undefined) ? c.firstSalt : obj.salt;\n\n  c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);\n  return { key: c[salt].slice(0), salt:salt.slice(0) };\n};\n"}